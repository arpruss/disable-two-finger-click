/*
 * Options:
 * --disable-two-finger-tap : don't just disable right button presses from two finger click, but 
 *							  also the ones coming from a tap 
 * --two-finger-detect-delay=x : a right button press coming less than x milliseconds after a 
 *								 two-finger contact counts as generated by the two-finger contact;
 *								 default 50 ms
 * --click-detect-delay=x      : a right button press coming less than x milliseconds after the touchpad
 *								 was pressured counts as generated by that, assuming two-finger contact;
 *								 default 50 ms
 */

#include <Windows.h>
#include <hidsdi.h>
#include <time.h>
#include <stdio.h>

#define OUT_BUFFER_SIZE 4096
#define IN_BUFFER_SIZE  4096


int disable_twofinger_tap_right_click = 0;
unsigned twofinger_detect_delay_clocks = CLOCKS_PER_SEC * 50 / 1000;
unsigned click_detect_delay_clocks = CLOCKS_PER_SEC * 50 / 1000;
HHOOK miHook;
unsigned num_fingers = 0;
clock_t last_click = 0;
clock_t last_two_finger_time = 0;

unsigned char outBuffer[OUT_BUFFER_SIZE];
unsigned outBufferHead;
unsigned outBufferTail;

HANDLE queueReady;
char running = 1;

int popBuffer() {
    if (outBufferHead == outBufferTail)
        return -1;
    unsigned char c = outBuffer[outBufferHead];
    outBufferHead = (outBufferHead+1) % OUT_BUFFER_SIZE;
    return c;
}

int pushBuffer(unsigned char c) {
    unsigned newTail = (outBufferTail+1) % OUT_BUFFER_SIZE;
    if (newTail == outBufferHead)
        return -1;
    outBuffer[outBufferTail] = c;
    outBufferTail = newTail;
    return 0;
}

DWORD WINAPI handleQueue(void* arg) {
    INPUT ip;
    ip.type = INPUT_MOUSE;
    ip.mi.dx = 0;
    ip.mi.dy = 0;
    ip.mi.mouseData = 0;
    ip.mi.time = 0;
    
    while(running) {
        WaitForSingleObject(queueReady, INFINITE);
        int c;
        while (running && (c = popBuffer()) >= 0) {
            if (c) 
                ip.mi.dwFlags = WM_RBUTTONDOWN;
            else
                ip.mi.dwFlags = WM_RBUTTONUP;
            SendInput(1,&ip,sizeof(INPUT));
        }
    }
    
    ExitThread(0);
    return 0;
}

LRESULT CALLBACK LowLevelMouseProc(int nCode, WPARAM wParam, LPARAM lParam) {
    static char remapped_down = 0;
    if(nCode == HC_ACTION) {
        if(wParam == WM_RBUTTONDOWN) {
            clock_t t = clock();
            if ( (num_fingers > 1 || t-last_two_finger_time<twofinger_detect_delay_clocks) &&
                 (disable_twofinger_tap_right_click || t-last_click<click_detect_delay_clocks) ) {
                pushBuffer(1);
                SetEvent(queueReady);
                remapped_down = 1;
                return 1;
            }
        }
        else if (wParam == WM_RBUTTONUP && remapped_down) {
            pushBuffer(0);
            SetEvent(queueReady);
            remapped_down = 0;
            return 1;
        }
    }
 
    return CallNextHookEx(miHook, nCode, wParam, lParam); // Important! Otherwise other mouse hooks may misbehave
}

int haveValueCap(HIDP_VALUE_CAPS* cap, unsigned usagePage, unsigned usage) {
	if (cap->UsagePage != usagePage)
		return 0;
	if (cap->IsRange) {
		return cap->Range.UsageMin <= usage && usage <= cap->Range.UsageMax;
	}
	else {
		return cap->NotRange.Usage == usage;
	}
}

int haveButtonCap(HIDP_BUTTON_CAPS* cap, unsigned usagePage, unsigned usage) {
	if (cap->UsagePage != usagePage)
		return 0;
	if (cap->IsRange) {
		return cap->Range.UsageMin <= usage && usage <= cap->Range.UsageMax;
	}
	else {
		return cap->NotRange.Usage == usage;
	}
}

// https://gist.github.com/luluco250/ac79d72a734295f167851ffdb36d77ee
LRESULT CALLBACK EventHandler(
    HWND hwnd,
    unsigned event,
    WPARAM wparam,
    LPARAM lparam
) {
    static BYTE rawinputBuffer[sizeof(RAWINPUT)+IN_BUFFER_SIZE];
	static BYTE preparsedBuffer[IN_BUFFER_SIZE];
	static BYTE usageBuffer[IN_BUFFER_SIZE];
	USAGE* usages = (USAGE*)usageBuffer;
	RAWINPUT* data = (RAWINPUT*)rawinputBuffer;
	PHIDP_PREPARSED_DATA preparsed = (PHIDP_PREPARSED_DATA)preparsedBuffer;
	
	static HIDP_CAPS caps;
	
    switch (event) {
        case WM_DESTROY:
            PostQuitMessage(0);
            return 0;
        case WM_INPUT: {
            unsigned size = sizeof(rawinputBuffer);
            int res = GetRawInputData((HRAWINPUT)lparam, RID_INPUT, data, &size, sizeof(RAWINPUTHEADER));
            if (res < 0 || size == 0 || data->header.dwType != RIM_TYPEHID) 
                return 0;
			size = sizeof(preparsedBuffer);
			res = GetRawInputDeviceInfo(data->header.hDevice, RIDI_PREPARSEDDATA, preparsed, &size);
			if (res < 0 || size == 0) 
				return 0;
			unsigned long count;
			res = HidP_GetUsageValue(HidP_Input, 0x0D, 0, 0x54, 
					&count, preparsed, data->data.hid.bRawData, data->data.hid.dwSizeHid);
			if (res < 0)
				return 0;

			unsigned long click = 0;
			if (!disable_twofinger_tap_right_click) {
				unsigned long usageLength = sizeof(usageBuffer)/sizeof(USAGE);
				
				res = HidP_GetUsages(HidP_Input, 0x0d, 0, usages, &usageLength, preparsed, data->data.hid.bRawData, data->data.hid.dwSizeHid);
				if (res < 0)
					return 0;
				
				for (int j=0;j<usageLength;j++)
					if (usages[j]==0x01) {
						click = 1;
						break;
					}
			}

			clock_t t = clock();
			
			num_fingers = count;
			if (num_fingers>=2)
				last_two_finger_time = t;
			if (click)
				last_click = t;
        } return 0;
    }

    return DefWindowProc(hwnd, event, wparam, lparam);
}

void processOptions(char* cmdLine) {
	char* token;
	char* src;
	src = cmdLine;

	while (NULL != (token = strtok(src, " "))) {
		if (!strcmp(token, "--disable-two-finger-tap")) {
			disable_twofinger_tap_right_click = 1;
		}
		else if (!strncmp(token, "--two-finger-detect-delay=", 26)) {
			twofinger_detect_delay_clocks = CLOCKS_PER_SEC * atoi(token+26) / 1000;
		}
		else if (!strncmp(token, "--click-detect-delay=", 21)) {
			click_detect_delay_clocks = CLOCKS_PER_SEC * atoi(token+21) / 1000;
		}
		src = NULL;
	}
}

//main() 
int WINAPI WinMain(HINSTANCE instance, HINSTANCE hPrevInstance,
    PSTR lpCmdLine, int nCmdShow)
{
    const char* class_name = "disable-two-finger-click-889239832489-class";
	
	processOptions(lpCmdLine);
	
    //HINSTANCE instance = GetModuleHandle(0);
    WNDCLASS window_class = {};
    window_class.lpfnWndProc = EventHandler;
    window_class.hInstance = instance;
    window_class.lpszClassName = class_name;

    if (!RegisterClass(&window_class))
        return -1;

    HWND window = CreateWindow(class_name, "disable-two-finger-click-889239832489", 0, 0, 0, 0, 0, HWND_MESSAGE, 0, 0, 0);

    if (window == NULL)
        return -1;

    RAWINPUTDEVICE rid;
    rid.usUsagePage = 0x0D;
    rid.usUsage = 0x05;
    rid.dwFlags = RIDEV_INPUTSINK;
    rid.hwndTarget = window;
    RegisterRawInputDevices(&rid, 1, sizeof(rid));

    miHook = SetWindowsHookEx(WH_MOUSE_LL, (HOOKPROC)(&LowLevelMouseProc), 0, 0);

    queueReady = CreateEvent(NULL, FALSE, FALSE, (LPTSTR)("queueReady"));
    HANDLE queueThread = CreateThread(NULL, 0, handleQueue, NULL, 0, NULL);

    MSG message;
    while(GetMessage(&message, NULL, 0, 0)) {
        TranslateMessage(&message);
        DispatchMessage(&message);
    }

    running = 0;
    SetEvent(queueReady);
    UnhookWindowsHookEx(miHook);
    return 0;
}